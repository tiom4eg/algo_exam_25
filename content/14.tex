\section{LCA/RMQ}

Считать LCA двоичными подъемами очень легко: будем бинарить $d$ - максимальную высоту, на которую можно поднять $u$, чтобы она не стала предком $v$ (проверять на то, является ли одна вершина предком другой, можно с помощью $tin$ и $tout$ за $O(1)$). Ясное дело, что по определению LCA, им будет $(d+1)$-й предок $u$.

Давайте выпишем высоты всех вершин в порядке посещения их эйлеровым обходом. Во-первых, заметим, что соседние высоты в обходе будут отличаться на $\pm 1$. Во-вторых, рассмотрим отрезок обхода $[\min(tout_u, tout_v); \max(tin_u, tin_v)]$ (в том случае, если никакая из вершин не является предком другой). В таком случае, LCA этих двух вершин будет лежать на соответствующем отрезке обхода, а все предки LCA - не будут, потому что $u$ и $v$ лежат в одном и том же поддереве их ребёнка (а следовательно, на отрезке обхода не может лежать ни одна вершина $w$, такая, что на пути $u \to w$ или $v \to w$ обязательно лежит отец $lca(u, v)$). Значит, минимальная высота на этом отрезке обхода будет принадлежать в точности $lca(u, v)$).

Научимся решать задачу RMQ$\pm 1$. Давайте заметим, что позиция минимума на отрезке определяется только разностями соседних элементов и не зависит от самих значений этих элементов. К примеру, можно считать, что первый элемент отрезка равен нулю (как будто мы вычли из всех элементов на отрезке первый), и в таком массиве минимум будет стоять на той же самой позиции, что и в изначальном. Поменяется лишь его значение. Но если мы найдем позицию минимума, найти его значение не составит труда: нужно лишь обратиться к соответствующему индексу изначального массива.

Теперь заметим, что если мы превратим все блоки в последовательности разностей соседних элементов, то эти последовательности будут состоять из чисел 1 и -1, тогда если длина блока равна $k$, то существует всего $2^{k-1}$ различных последовательностей разностей соседних элементов. После чего мы можем заранее предпосчитать для каждой такой последовательности минимум на каждом подотрезке. На это уйдет $O(2^{k-1} k^2)$ времени. И затем просто для каждого блока в массиве определить, к какому типу он относится, и пользоваться предпосчитанными значениями позиций минимумов для всех маленьких подотрезков для ответа на запросы в будущем. Можно выбрать $k = \frac{\log n}{2}$, тогда спарсы на блоках длины $k$ строятся за $O(n)$, а $O(2^{k-1} k^2) = O(\sqrt{n} \log^2 n) < O(n)$.

Аналогичную идею можно применить и для общей задачи RMQ. Опять разделим всё на блоки размера $O(\log n)$, в каждом блоке для каждой правой границы $r$ насчитаем маску стека минимумов на отрезке $[block\_l; r]$, это делается за длину блока (поскольку каждый элемент добавляется и удаляется из стека не более раза). Пусть мы хотим найти минимум на отрезке $[l; r]$, который целиком лежит внутри какого-то блока. Из-за того, как устроен стек минимумов, минимальным элементом на отрезке будет ближайший справа от $l$ единичный бит в маске границы $r$, он находится либо предпосчетом с помощью 4 русских, либо с помощью допущения о том, что любые арифметические операции (в том числе и \texttt{ctz}) с числами порядка $n$ работают за $O(1)$. Опять строим спарсы на блоках, каждый запрос разбивается на запрос к спарсам + не более двух запросов внутри блоков, получили $O(n)/O(1)$ как и хотели.
