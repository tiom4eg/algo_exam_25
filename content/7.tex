\section{Амортизированные очереди, деки (с поддержкой минимума)}

Исходно у нас есть структура стек, которую понятно, как реализовывать. Мы хотим реализовать очередь/дек с эффективным использованием памяти. Реализуем очередь на двух стеках: $st_{head}, \ st_{tail}$. В качестве потенциала возьмём $|st_{tail}|$. При добавлении элемента будем добавлять его наверх $st_{tail}$, выполнится одна операция, потенциал увеличится на 1, поэтому $a_i = 1 + 1 = 2$. При удалении элемента посмотрим на то, пусть ли $st_{head}$. Если нет - удалим элемент с его верхушки, потенциал не изменится $\implies a_i = 1 + 0 = 1$. Если же он пуст, то перенесём в него все элементы из $st_{tail}$ по одному, понятно, что верхний элемент в $st_{tail}$ будет нижним в $st_{head}$ и наоборот, это будет корректным порядком для $st_{head}$. Будет выполнено $|st_{tail}|$ операций сложности $O(1)$ для переноса и потенциал уменьшится на $|st_{tail}|$, после чего будет извлечён элемент с верхушки $st_{head}$ как и в прошлом случае, значит $a_i = k - k + 1 = 1$. Доказали, что $a_i = O(1)$, $\Phi_i = O(n)$, поскольку в любой момент размер никакого из стеков не мог превысить общее число операций ($n$), значит, средняя стоимость операции равна $O(1)$.

Дек можно реализовать с помощью трёх стеков. Первые два будут как и раньше $st_{head}, \ st_{tail}$, потенциалом будет $3 \cdot \max(|st_{head}|, \ |st_{buf}|)$. Третьим будет $st_{buf}$, который мы будем использовать как вспомогательный буфер при операции ребаланса. При \texttt{push\_front} или \texttt{push\_back} будем добавлять соответствующий элемент наверх нужного стека, при \texttt{pop\_front} или \texttt{pop\_back}, если нужный стек - непустой, будем забирать из него верхний элемент. Остается последний случай - когда мы пытаемся забрать верхний элемент из стека, который является пустым. Предположим, что пустым является $st_{head}$, а $st_{tail}$ непуст. Перекинем половину элементов $st_{tail}$ в $st_{buf}$, оставшиеся перекинем в $st_{head}$ (они при этом поменяют свой порядок на обратный, то есть нужный), затем из $st_{buf}$ вернём элементы в $st_{tail}$. После таких действий элементы сохранят нужный порядок, при этом потенциал поделится примерно пополам. Значит, $a_i = 1.5 \max(|st_{head}|, \ |st_{buf}|) - 0.5\Phi_i + O(1) = O(1)$, остальные операции имеют стоимость $O(1)$ аналогично очереди.

Чтобы всё это могло поддерживать минимум, будем реализовывать соответствующие структуры на стеках с поддержкой минимума. Стек с поддержкой минимума будет просто поддерживать стек рекордов вместе с элементами. Понятное дело, что добавление поддержки стека рекордов - гарантированное $O(1)$, так что амортизация не поломается.
