\section{2-3 дерево и B-деревья}

2-3 дерево — сбалансированное дерево поиска, обладающее следующими свойствами:

$\bullet$ нелистовые вершины имеют либо 2, либо 3 сына

$\bullet$ нелистовая вершина, имеющая двух сыновей, хранит максимум левого поддерева. Нелистовая вершина, имеющая трех сыновей, хранит два значения. Первое значение хранит максимум левого поддерева, второе максимум центрального поддерева

$\bullet$ сыновья упорядочены по значению максимума поддерева сына

$\bullet$ все листья лежат на одной глубине

$\bullet$ высота 2-3 дерева: $O(\log n)$

Основные операции:

\subsection{Поиск}

Находим сына, в которого нужно спуститься, проверяя по очереди максимумы в поддеревьях. Операция работает за высоту дерева, то есть $O(\log n)$.

\subsection{Вставка}

С помощью спуска найдем позицию, где должен стоять добавляемый элемент, после чего попробуем добавить его в качестве сына к родителю. Если после этого у родителя станет 4 ребёнка, то разделим родителя на двух детей, левому из которых отойдет два левых ребёнка, а правому - два правых. После этого уже для их родителя проверим число детей и, если нужно, произведём разделение. Будем так делать, пока не попадём в вершину, у которой не 4 ребёнка (при этом, мы можем получить новый корень дерева в результате выполнения разделений). При каждом разделении вершины на две придется пересчитать данные для неё и её клона, а также для их родителя, что занимает $O(1)$ времени. Поскольку разделять будем только вершины на пути к корню, операция работает за $O(\log n)$.

\subsection{Удаление}

Пусть $t$ - вершина, которую нужно удалить. Если у её отца больше двух детей, то всё тривиально - просто удалим эту вершину, структура дерева больше никак не поменяется. Иначе, пусть $b$ - брат $t$ (другой ребёнок отца $t$), $p$ - отец $t$, $gp$ - отец $p$ ("дедушка"), $np$ - брат $p$. Сразу отсечём тривиальные случаи, где $t$ - корень или сын корня. Если $p$ существует, и у него строго больше 2 сыновей, то просто удалим $t$, а у $p$ уменьшим количество детей.

Если у $p$ два сына, рассмотрим возможные случаи (сперва везде удаляем $t$):

$\bullet$ у $gp$ оказалось 2 сына, у $np$ оказалось 2 сына. Подвесим $b$ к $np$ и удалим $p$. Так как у $gp$ оказалось тоже два сына, повторяем для $p$ те же рассуждения

$\bullet$ у $gp$ оказалось 2 или 3 сына, у $np$ оказалось 3 сына. Просто заберем ближайшего к нам сына у $np$ и прицепим его к $p$. Восстановим порядок в сыновьях $p$. Теперь у $p$ оказалось снова два сына и все узлы дерева корректны

$\bullet$ у $gp$ оказалось 3 сына, у $np$ оказалось 2 сына. Подвесим $b$ к $np$ и удалим $p$, а у $gp$ уменьшим количество детей. Так как у $np$ оказалось три сына, а у $gp$ все ещё больше одного сына, то все узлы дерева корректны

\subsection{(Batch) prev/next}

В случае \texttt{next} будем подниматься вверх, пока не появится опция пройти в более правого ребёнка, после чего спустимся в ближайшего ребёнка справа, а в нём - в самую левую вершину, которая будет ближайшей справа. Для \texttt{prev} аналогично, но с поиском ребёнка левее. Работает за $O(\log n)$ (спуск + подъём + снова спуск).

Чтобы находить \texttt{next} или \texttt{prev} $k$ раз подряд за $O(k + \log n)$, можно хранить двусвязный список на листьях, при каждой вставке/удалении обновление ссылок тривиально без ухудшения асимптотики \\ (поскольку поиск следующего/предыдущего тоже работает за $O(\log n)$).

\subsection{B-деревья}

B-деревья будут иметь ту же структуру, за единственным отличием - вместо минимум двух и максимум трёх детей, каждая вершина может иметь минимум $b$ и максимум $2b$ детей (кроме корня, он может иметь не более $2b$ детей). Операции работают абсолютно таким же образом (только с константой $b$ для поиска нужного ребёнка/прохода по всем детям вершины). Для чего это нужно? Вспомним про существование внешней памяти, где доступ к диску на несколько порядков дороже, чем операция в RAM, тогда понижение высоты дерева (= понижение числа детей, которых мы будем подгружать из памяти) ценой увеличения числа выполняемых в RAM операций вполне имеет смысл.
