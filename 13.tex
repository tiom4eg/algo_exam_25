\section{Персистентность}

Персистентные структуры данных — это структуры данных, которые при внесении в них изменений сохраняют доступ ко всем своим предыдущим состояниям.

Есть несколько «уровней» персистентности: частичная — к каждой версии можно делать запросы, но изменять можно только последнюю, полная — можно делать запросы к любой версии и менять любую версию, конфлюэнтная — помимо этого можно объединять две структуры данных в одну (например, сливать вместе кучи или деревья поиска). Также стоит отметить, что амортизация и персистентность вместе не работают, поскольку мы можем найти операцию, которая выполняется долго и попросить повторить её много раз, что сломает асимптотику.

Для того, чтобы реализовать персистентный стек, достаточно вспомнить, что стек это, по сути, односвязный список, к тому же во время запросов мы "дёргаем" только последний его элемент. Тогда, в качестве версии стека будем хранить значение его верхнего элемента и ссылка на версию стека без последнего элемента (такая точно будет существовать, поскольку последний элемент когда-то был добавлен, и в этот момент стек, очевидно, состоял из всех элементов, кроме добавленного). При добавлении элемента создадим новую версию со ссылкой на текущую, при удалении перейдём в ту версию, на которую ведёт ссылка (изначально будет существовать пустой стек с версией 0). Всё это, очевидно, работает за гарантированное $O(1)$.

Персистентное дерево отрезков основывается на идее того, что за один запрос дерева отрезков мы проходимся по не более чем $O(\log n)$ вершинам (на самом деле, это работает для вообще всех структур без амортизации, например для ДД). Тогда при изменении информации в вершине будем создавать копию текущей вершины, изменять данные уже в ней (чтобы не испортить старые версии) и возвращать указатель на новую версию вершины, чтобы обновить указатели на детей в той вершине, из которой пришли в текущую. Это обеспечивает полную персистентность за $O(\log n)$.

Теперь покажем, как можно реализовать персистентную очередь. Автору данной секции очень не понравилось легендарное решение с 6 (или 5) стеками, поэтому он воспользуется другой идеей, которая использует тот факт, что у нас есть именно персистентные стеки. Итак, пусть у нас есть персистентный стек $st_{all}$, в котором хранятся все когда-либо добавленные элементы. Заведём два стека $st_{head}$ и $st_{future}$. В $st_{head}$ будут лежать элементы с начала очереди, в $st_{future}$ будет набираться будущая версия $st_{head}$ (а ещё, эти стеки тоже должны быть персистентными, чтобы копирование работало за $O(1)$). Итак, что мы будем делать - каждый раз, когда $st_{future}$ пустой, мы будем с конца добавлять в него по одному актуальные элементы $st_{all}$ (они, очевидно, образуют некоторый суффикс). Когда в $st_{future}$ наберутся все нужные элементы, переложим его в $st_{head}$ и начнём набирать новый $st_{future}$. При операции удаления элемента из начала очереди, будем брать верхний элемент из $st_{head}$. Теперь докажем, что если после выполнения каждой операции над очередью добавлять один элемент в $st_{future}$, то $st_{head}$ никогда не опустеет раньше времени и всё будет работать корректно. Итак, после добавления первого элемента, мы сразу же добавим его в $st_{future}$, который переложим в $st_{head}$. Запомним это состояние как "обнуление" и "обнулением" будем называть всякое такое состояние, в котором $st_{head}$ только что было присвоено новое значение, а $st_{future}$ был очищен. Докажем, что между обнулениями $st_{head}$ не обнулится, а в $st_{future}$ будут добавлены только нужные элементы. Второе сразу следует из того, что мы проверяем добавляемый в $st_{future}$ элемент на актуальность. С первым всё тоже несложно - пусть после последнего обнуления в $st_{head}$ осталось $n$ элементов. Понятно, что $st_{future}$, который превратился в $st_{head}$, набирался на протяжении $n$ операций, среди которых было не более $n$ добавлений новых элементов. Таким образом, даже если все операции после этого обнуления будут удалением элемента из начала очереди, мы успеем заполнить $st_{future}$ и положить новую версию в $st_{head}$ до того, как нам поступит запрос на удаление из непустого стека (заметим, что запросы добавления элемента делают нам только лучше, поскольку число элементов, которые надо положить в $st_{future}$ фиксируется на момент обнуления). Корректность доказана, асимптотика будет $O(1)$, поскольку мы выполняем всего одно добавление элемента в $st_{future}$ за операцию плюс выполняем ещё $O(1)$ других операций, которые занимают $O(1)$ времени (поскольку копирование персистентных стеков и откат в них занимает $O(1)$ времени).
